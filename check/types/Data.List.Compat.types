(!!) :: [a] -> GHC.Types.Int -> a
(\\) :: GHC.Classes.Eq a => [a] -> [a] -> [a]
(++) :: [a] -> [a] -> [a]
all :: Data.Foldable.Foldable t =>    (a -> GHC.Types.Bool)    -> t a -> GHC.Types.Bool
and :: Data.Foldable.Foldable t =>    t GHC.Types.Bool -> GHC.Types.Bool
any :: Data.Foldable.Foldable t =>    (a -> GHC.Types.Bool)    -> t a -> GHC.Types.Bool
break :: (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
concat :: Data.Foldable.Foldable t => t [a] -> [a]
concatMap :: Data.Foldable.Foldable t => (a -> [b]) -> t a -> [b]
cycle :: [a] -> [a]
delete :: GHC.Classes.Eq a => a -> [a] -> [a]
deleteBy :: (a -> a -> GHC.Types.Bool) -> a -> [a] -> [a]
deleteFirstsBy :: (a -> a -> GHC.Types.Bool) -> [a] -> [a] -> [a]
drop :: GHC.Types.Int -> [a] -> [a]
dropWhile :: (a -> GHC.Types.Bool) -> [a] -> [a]
dropWhileEnd :: (a -> GHC.Types.Bool) -> [a] -> [a]
elem :: (Data.Foldable.Foldable t, GHC.Classes.Eq a) =>    a -> t a -> GHC.Types.Bool
elemIndex :: GHC.Classes.Eq a =>    a -> [a] -> GHC.Maybe.Maybe GHC.Types.Int
elemIndices :: GHC.Classes.Eq a =>    a -> [a] -> [GHC.Types.Int]
filter :: (a -> GHC.Types.Bool) -> [a] -> [a]
find :: Data.Foldable.Foldable t =>    (a -> GHC.Types.Bool) -> t a -> GHC.Maybe.Maybe a
findIndex :: (a -> GHC.Types.Bool)    -> [a] -> GHC.Maybe.Maybe GHC.Types.Int
findIndices :: (a -> GHC.Types.Bool)    -> [a] -> [GHC.Types.Int]
foldl :: Data.Foldable.Foldable t => (b -> a -> b) -> b -> t a -> b
foldl' :: Data.Foldable.Foldable t => (b -> a -> b) -> b -> t a -> b
foldl1 :: Data.Foldable.Foldable t => (a -> a -> a) -> t a -> a
foldl1' :: (a -> a -> a) -> [a] -> a
foldr :: Data.Foldable.Foldable t => (a -> b -> b) -> b -> t a -> b
foldr1 :: Data.Foldable.Foldable t => (a -> a -> a) -> t a -> a
genericDrop :: GHC.Real.Integral i => i -> [a] -> [a]
genericIndex :: GHC.Real.Integral i => [a] -> i -> a
genericLength :: GHC.Num.Num i => [a] -> i
genericReplicate :: GHC.Real.Integral i => i -> a -> [a]
genericSplitAt :: GHC.Real.Integral i => i -> [a] -> ([a], [a])
genericTake :: GHC.Real.Integral i => i -> [a] -> [a]
group :: GHC.Classes.Eq a => [a] -> [[a]]
groupBy :: (a -> a -> GHC.Types.Bool) -> [a] -> [[a]]
head :: [a] -> a
init :: [a] -> [a]
inits :: [a] -> [[a]]
insert :: GHC.Classes.Ord a => a -> [a] -> [a]
insertBy :: (a -> a -> GHC.Types.Ordering) -> a -> [a] -> [a]
intercalate :: [a] -> [[a]] -> [a]
intersect :: GHC.Classes.Eq a => [a] -> [a] -> [a]
intersectBy :: (a -> a -> GHC.Types.Bool) -> [a] -> [a] -> [a]
intersperse :: a -> [a] -> [a]
isInfixOf :: GHC.Classes.Eq a =>    [a] -> [a] -> GHC.Types.Bool
isPrefixOf :: GHC.Classes.Eq a =>    [a] -> [a] -> GHC.Types.Bool
isSubsequenceOf :: GHC.Classes.Eq a =>    [a] -> [a] -> GHC.Types.Bool
isSuffixOf :: GHC.Classes.Eq a =>    [a] -> [a] -> GHC.Types.Bool
iterate :: (a -> a) -> a -> [a]
iterate' :: (a -> a) -> a -> [a]
last :: [a] -> a
length :: Data.Foldable.Foldable t => t a -> GHC.Types.Int
lines :: GHC.Base.String -> [GHC.Base.String]
lookup :: GHC.Classes.Eq a =>    a -> [(a, b)] -> GHC.Maybe.Maybe b
map :: (a -> b) -> [a] -> [b]
mapAccumL :: Data.Traversable.Traversable t =>    (a -> b -> (a, c)) -> a -> t b -> (a, t c)
mapAccumR :: Data.Traversable.Traversable t =>    (a -> b -> (a, c)) -> a -> t b -> (a, t c)
maximum :: (Data.Foldable.Foldable t, GHC.Classes.Ord a) =>    t a -> a
maximumBy :: Data.Foldable.Foldable t =>    (a -> a -> GHC.Types.Ordering) -> t a -> a
minimum :: (Data.Foldable.Foldable t, GHC.Classes.Ord a) =>    t a -> a
minimumBy :: Data.Foldable.Foldable t =>    (a -> a -> GHC.Types.Ordering) -> t a -> a
notElem :: (Data.Foldable.Foldable t, GHC.Classes.Eq a) =>    a -> t a -> GHC.Types.Bool
nub :: GHC.Classes.Eq a => [a] -> [a]
nubBy :: (a -> a -> GHC.Types.Bool) -> [a] -> [a]
null :: Data.Foldable.Foldable t => t a -> GHC.Types.Bool
or :: Data.Foldable.Foldable t =>    t GHC.Types.Bool -> GHC.Types.Bool
partition :: (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
permutations :: [a] -> [[a]]
product :: (Data.Foldable.Foldable t, GHC.Num.Num a) => t a -> a
repeat :: a -> [a]
replicate :: GHC.Types.Int -> a -> [a]
reverse :: [a] -> [a]
scanl :: (b -> a -> b) -> b -> [a] -> [b]
scanl' :: (b -> a -> b) -> b -> [a] -> [b]
scanl1 :: (a -> a -> a) -> [a] -> [a]
scanr :: (a -> b -> b) -> b -> [a] -> [b]
scanr1 :: (a -> a -> a) -> [a] -> [a]
sort :: GHC.Classes.Ord a => [a] -> [a]
sortBy :: (a -> a -> GHC.Types.Ordering) -> [a] -> [a]
sortOn :: GHC.Classes.Ord b => (a -> b) -> [a] -> [a]
span :: (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
splitAt :: GHC.Types.Int -> [a] -> ([a], [a])
stripPrefix :: GHC.Classes.Eq a =>    [a] -> [a] -> GHC.Maybe.Maybe [a]
subsequences :: [a] -> [[a]]
sum :: (Data.Foldable.Foldable t, GHC.Num.Num a) => t a -> a
tail :: [a] -> [a]
tails :: [a] -> [[a]]
take :: GHC.Types.Int -> [a] -> [a]
takeWhile :: (a -> GHC.Types.Bool) -> [a] -> [a]
transpose :: [[a]] -> [[a]]
uncons :: [a] -> GHC.Maybe.Maybe (a, [a])
unfoldr :: (b -> GHC.Maybe.Maybe (a, b)) -> b -> [a]
union :: GHC.Classes.Eq a => [a] -> [a] -> [a]
unionBy :: (a -> a -> GHC.Types.Bool) -> [a] -> [a] -> [a]
unlines :: [GHC.Base.String] -> GHC.Base.String
unwords :: [GHC.Base.String] -> GHC.Base.String
unzip :: [(a, b)] -> ([a], [b])
unzip3 :: [(a, b, c)] -> ([a], [b], [c])
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])
words :: GHC.Base.String -> [GHC.Base.String]
zip :: [a] -> [b] -> [(a, b)]
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]
zip7 :: [a]    -> [b]    -> [c]    -> [d]    -> [e]    -> [f]    -> [g]    -> [(a, b, c, d, e, f, g)]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
zipWith5 :: (a -> b -> c -> d -> e -> f)    -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
zipWith6 :: (a -> b -> c -> d -> e -> f -> g)    -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h)    -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
